<article>
  <title>Parallelizing a CLIPS-based course timetabling expert system</title>
  <abstract>
    <sentence>Course timetabling is a complex task that cannot be achieved using only a few general principles.</sentence>
    <sentence>This work integrates expert systems and constraint programming to generate a novel artificial intelligence approach for a course timetabling system.</sentence>
    <sentence>This approach can be easily reformulated and customized to sup-port requirement changes.</sentence>
    <sentence>Furthermore, the difference between hard and soft constraints can be also addressed easily.</sentence>
    <sentence>However, achieving a feasible timetable is very time consuming because the inference engine is CLIPS-based.</sentence>
    <sentence>Notably, CLIPS is a rule-based language that relies on the repeated matching of facts with rules to generate conclusions.</sentence>
    <sentence>To overcome the problem, this work parallelizes the execution of the timetabling system in emerging cluster systems.</sentence>
    <sentence>However, scheduling courses in parallel without solving assignment conflicts is difficult.</sentence>
    <sentence>To conquer the inherent serialization of the inference of course timetabling, courses are scheduled one by one and the schedule for one course is parallelized.</sentence>
    <sentence>This work utilizes the inference process for scheduling one course that behaves similar to the nested if–then–else structure.</sentence>
    <sentence>The rules for the inference process of scheduling one course are partitioned into multiple rule clusters, where each rule cluster is inferred by a slave process.</sentence>
    <sentence>After receiving all feasible solutions generated by slave processes, the master decides which solution to adopt for a current course according to rule priorities.</sentence>
    <sentence>However, improper division of rules can result in a false conclusion or runtime errors.</sentence>
    <sentence>To ensure that a correct timetable is obtained, two possible problems caused by improper rule division are identified.</sentence>
    <sentence>Three partitioning guidelines are then used to cope with these problems.</sentence>
    <sentence>For implementation, this work applied a novel programming model that transmits facts in C and infers rules in CLIPS.</sentence>
    <sentence>Experimental results demonstrate that the proposed parallel timetabling system achieves superlinear speedup when running in a cluster system.</sentence>
    <sentence>The proposed method also helps parallelize CLIPS-based expert systems that have similar inference behavior to that in the course timetabling system.</sentence>
  </abstract>
  <keywords>
    <keyword>Course timetabling</keyword>
    <keyword>Parallel computing</keyword>
    <keyword>CLIPS</keyword>
    <keyword>Expert system</keyword>
    <keyword>Cluster system</keyword>
  </keywords>
  <section name="Introduction">
    <sentence>The course timetabling problem is to allocate a set of courses into predetermined time slots (typically within one week), while satisfying a set of constraints.</sentence>
    <sentence>This complex problem cannot be dealt with using only a few general principles.</sentence>
    <sentence>To address this timetabling problem, most work has employed graph coloring (de Werra, 1997), integer programming (Daskalaki &amp; Birbas, 2005), tabu search (Santos, Ochi, &amp; Souza, 2005; Schaerf, 1999), genetic algorithms (Ueda, Ouchi, Takahashi, &amp; Miyahara, 2004), neural networks (Carrasco &amp; Pato, 2004), human-machine interactions (Mulvey, 1982), decision support systems (Dimopoulou &amp; Miliotis, 2001; Foulds &amp; Johnson, 2000), constraint programming (Deris, Omatu, &amp; Ohta, 2000; Valouxis &amp; Housos, 2003), or expert systems (Gunsdhi, Anand, &amp; Yong, 1996; Isaai &amp; Cassaigne, 2001).</sentence>
    <sentence>A course timetabling system is implemented using a novel artificial intelligence approach that integrates expert systems and constraint programming (Lai, Wu, Hsueh, Huang, &amp; Hwang, 2008).</sentence>
    <sentence>The proposed approach has the following advantages.</sentence>
    <sentence>(1) Timetabling systems are easily reformulated or customized to support changes, as the timetabling problem varies significantly from institution to institution in terms of specific requirements and constraints.</sentence>
    <sentence>(2) One can easily capture knowledge and incorporate this knowledge into a timetabling system as expertise reduces the search space and fits the solution to the context.</sentence>
    <sentence>(3) The difference between hard constraints and soft constraints can be addressed.</sentence>
    <sentence>Although the proposed course timetabling system is superior to previous work, achieving a feasible solution is very time-consuming because the inference engine of the proposed expert system is C Language Integrated Production System (CLIPS)-based (CLIPS, 2009).</sentence>
    <sentence>Unlike conventional algorithmic languages, such as C, Java, and Visual Basic, a CLIPS programmer does not have to give the exact details on how a problem will be solved.</sentence>
    <sentence>Instead, the programmer only has to specify the goal and rules for handling various conditions.</sentence>
    <sentence>The underlying mechanism of the inference engine implementation itself tries to satisfy the goal.</sentence>
    <sentence>Because the key feature of expert systems is to solve problems for which no algorithms exist, CLIPS language is more suitable than any conventional algorithmic language for building expert systems.</sentence>
    <sentence>To reduced execution time for CLIPS-based programs, this work parallelizes timetabling execution in emerging cluster systems.</sentence>
    <sentence>A cluster system is a parallel and distributed processing system consisting of a collection of interconnected stand-alone computers working as a single, integrated computing resource (Buyya, 1999).</sentence>
    <sentence>A computer node can be a single- or multi-processor system, such as Personal Computers (PCs), workstations, or Symmetric Multiprocessors (SMPs).</sentence>
    <sentence>Nodes can exist in a single cabinet or be physically separated and connected via a Local Area Network (LAN).</sentence>
    <sentence>Assisted by a cluster middleware and related software, an interconnected computer cluster can appear as a single system to users and applications.</sentence>
    <sentence>Such a system is a much more cost-effective method than traditional expensive supercomputers for gaining similar features and benefits.</sentence>
    <sentence>The advantages of cluster systems are low cost, high performance, configurability, and scalability.</sentence>
    <sentence>Cluster systems are rapidly becoming standard platforms for high-performance computing, and a variety of clusters has been constructed.</sentence>
    <sentence>The most significant challenge in parallelizing a course timetabling system is its inherent serialization of inference.</sentence>
    <sentence>Scheduling courses in parallel without solving assignment conflicts is extremely difficult.</sentence>
    <sentence>Therefore, rather than scheduling courses by a certain scheduling resource, this work schedules courses in a one-by-one manner and parallelizes the inference process of scheduling one course because the process has a behavior similar to that of the nested if–then–else structure.</sentence>
    <sentence>The CLIPS rules are divided into multiple rule clusters for parallel inferences.</sentence>
    <sentence>According to inference priority, one parallel inference result will be chosen for scheduling a current course.</sentence>
    <sentence>However, an improper rule partition can result in a false conclusion, an infinite loop, or runtime errors.</sentence>
    <sentence>Therefore, this work introduces three partitioning guidelines for dividing rules and designing safe CLIPS codes.</sentence>
    <sentence>To execute a CLIPS application in parallel in a cluster system, the MPICH library is used for inter-processor communication.</sentence>
    <sentence>However, CLIPS programs cannot be parallelized directly because CLIPS language does not support this feature.</sentence>
    <sentence>Thus, this work modified the CLIPS inference engine by adding MPICH library functions because the inference engine is based on C language.</sentence>
    <sentence>Furthermore, the facts from the CLIPS program are removed and added to a C file, leaving only rules in the original CLIPS program.</sentence>
    <sentence>To integrate CLIPS data into the C file, the facts must be converted into the C data format.</sentence>
    <sentence>During run time, the C-format facts are distributed to multiple processes to reduce execution time for making inferences.</sentence>
    <sentence>After receiving the C-format facts, each slave process must convert the facts into CLIPS-format facts and insert these facts into the fact list in the inference engine.</sentence>
    <sentence>Similarly, following inference, each slave process extracts the inference result from its inference engine, converts the inference result back into the C format, and sends the C-format inference result back to the master process.</sentence>
    <sentence>This work implemented the proposed parallel timetabling system in a cluster system.</sentence>
    <sentence>Experimental results demonstrate that the proposed parallel system achieves superlinear speedup.</sentence>
    <sentence>For CLIPS-based expert systems that have an inference feature similar to that of course timetabling, these systems can be parallelized using the proposed method with a reasonable response time.</sentence>
    <sentence>The remainder of this paper is organized as follows.</sentence>
    <sentence>Section 2 introduces related work.</sentence>
    <sentence>Section 3 presents the proposed course timetabling expert system.</sentence>
    <sentence>Section 4 demonstrates how to parallelize the course timetabling system.</sentence>
    <sentence>Section 5 gives experimental results.</sentence>
    <sentence>Finally, Section 6 provides conclusions.</sentence>
  </section>
  <section name="Related work">
    <sentence>A wide variety of approaches to the timetabling problem have been proposed.</sentence>
    <sentence>Monfroglio (1988) proposes a Prolog-based system that employs backtracking for finding feasible timetables.</sentence>
    <sentence>The system decomposes and classifies constraints with respect to message passing and constraint ordering in order to minimize the backtracking and maximize the parallelism.</sentence>
    <sentence>Deris et al.</sentence>
    <sentence>(2000) propose a constraint-based reasoning algorithm to model and solve the timetabling problem.</sentence>
    <sentence>The proposed system is implemented via an object-oriented approach, and can therefore be easily adapted to support changes.</sentence>
    <sentence>In Valouxis and Housos (2003), operational research models and local search techniques are used to assist the constraint programming search process by effectively reducing the solution search space.</sentence>
    <sentence>The authors propose a minimum cost matching algorithm to relax the constraint satisfaction model.</sentence>
    <sentence>Constraint logic programming integrates logic programming and constraint solving so as to tackle combinatorial problems such as planning, scheduling, and resource allocation (Boizumault, Delon, &amp; Peridy, 1996).</sentence>
    <sentence>This combination helps to make constraint logic programs expressive and flexible.</sentence>
    <sentence>Gunsdhi et al.</sentence>
    <sentence>(1996) introduce an automated timetabler that combines a data model and a knowledge base, developed via object-oriented methodology.</sentence>
    <sentence>Separating out the data, the knowledge, and the algorithms provides the flexibility to deal with changes, and the incorporation of human expertise helps to reduce the feasible solution search space.</sentence>
    <sentence>Solotorevsky, Gudes, and Meisels (1994) develop a rule-based language, called RAPS, for specifying resource allocation problems and timetabling problems.</sentence>
    <sentence>The language enables the specification of a problem in terms of resources, activities, allocation rules, and constraints, and thereby provides a convenient knowledge acquisition tool.</sentence>
    <sentence>Dhar and Ranganathan (1990) propose the use of an expert system, called PROTEUS, for the allocation of teachers to courses, and compare it with integer programming techniques.</sentence>
    <sentence>For predictive scheduling of passenger trains, Isaai and Cassaigne (2001) introduce a lookahead, constraint-based algorithm that is designed using an object-oriented approach.</sentence>
    <sentence>In their approach, expert knowledge is used as a heuristic for finding practical solutions and is combined with the constraint-propagation technique.</sentence>
    <sentence>CLIPS (C Language Integrated Production System) is a popular tool for building expert systems (CLIPS, 2009).</sentence>
    <sentence>It consists of three components: facts, rules, and an inference engine, where the rules form the knowledge base.</sentence>
    <sentence>To solve a problem, CLIPS must have data or information with which to reason.</sentence>
    <sentence>Each chunk of information is called a fact.</sentence>
    <sentence>CLIPS contains an inference engine which controls the execution of the rules in the knowledge base.</sentence>
    <sentence>The basic strategy used is known as forward chaining; this leads naturally to bottom-up, data-driven reasoning.</sentence>
    <sentence>The agenda is how CLIPS keeps track of which rules are to be executed next.</sentence>
    <sentence>A rule is added to the agenda when all its conditions are satisfied.</sentence>
    <sentence>The activated rule with the highest priority in the agenda will be selected and executed repeatedly until the agenda becomes empty.</sentence>
    <sentence>To specify which rule should be matched before which rule, each rule is associated with a user-defined salience value.</sentence>
    <sentence>A rule with a larger salience value implies it has higher priority of performing pattern matching.</sentence>
    <sentence>Therefore, all the rules will be matched in the order specified by their salience values.</sentence>
    <sentence>If all the conditions of a rule are satisfied, its actions, listed on the right hand side of the rule, will be fired.</sentence>
    <sentence>The fired actions usually assert new facts into the knowledge base, resulting in that the inference engine will match the newly asserted facts with all rules for further inference.</sentence>
    <sentence>Due to the characteristics of rule-based languages, CLIPS usually needs to take a very long time to complete an execution.</sentence>
    <sentence>There has been some research done previously to improve the performance by parallelization.</sentence>
    <sentence>Riley (1987) parallelized CLIPS on a FLEX 32 platform that is a large-grain shared-memory parallel computer.</sentence>
    <sentence>He proposed to divide the whole set of rules into several subsets and to allocate these subsets to several processors.</sentence>
    <sentence>Hall, Bennett, and Tello (1994) implemented the parallelization on Intel Hypercubes architecture.</sentence>
    <sentence>The user interface is the same as the original CLIPS.</sentence>
    <sentence>They only inserted some parallel calls and commands to make the CLIPS able to run on each node of the Hypercubes.</sentence>
    <sentence>Furthermore, the parallel commands can insert or remove the facts into/from the memory of remote nodes.</sentence>
    <sentence>Gagne and Garant (1994) combined CLIPS and distributed system architecture.</sentence>
    <sentence>DAI-CLIPS is a distributed computational environment.</sentence>
    <sentence>Each CLIPS in it is an active independent computational entity.</sentence>
    <sentence>They can communicate with other CLIPS processes.</sentence>
    <sentence>Also, they can create, modify, or delete the expertise of CLIPS.</sentence>
    <sentence>Myers and Pohl (1994) parallelized CLIPS by PVM (Parallel Virtual Machine).</sentence>
    <sentence>PVM is a library of C and FORTRAN.</sentence>
    <sentence>It supports distributive computing on distributed UNIX systems.</sentence>
    <sentence>They used the MPMD model to parallelize CLIPS, and made it able to run in heterogeneous distributive computing environments.</sentence>
    <sentence>Another related work is about Jess, a Java version of CLIPS.</sentence>
    <sentence>Petcu (2005) proposed parallel Jess for homogeneous cluster of workstations.</sentence>
    <sentence>He used JPVM to parallelize an expert system application.</sentence>
    <sentence>A wrapper was designed to allow the cooperation between several instances of Jess running on different computers.</sentence>
    <sentence>The wrapper must be the same or slightly different for most of the available expert systems.</sentence>
    <sentence>In our previous work, we have proposed two methods to parallelize the CLIPS-based expert systems.</sentence>
    <sentence>Both of them adopt the SPMD (Single Program Multiple Data) programming model for easy maintenance (Wilkinson &amp; Allen, 2005).</sentence>
    <sentence>In the first method, we propose a Grid-enabled CLIPS language that is extended by using the interface of the External Function Definition provided by the CLIPS interpreter (Wu, Lai, &amp; Chang, 2008a, 2008b).</sentence>
    <sentence>In this way parallel syntax can be defined based on the original CLIPS programming style.</sentence>
    <sentence>As a result, the proficient CLIPS programmers have no need to learn the C language to develop parallel expert systems.</sentence>
    <sentence>They only need to learn the basic parallel programming knowledge and use the simple CLIPS-style parallel routines such as send, receive, and synchronization to develop parallel CLIPS applications.</sentence>
    <sentence>The supported parallel syntaxes are simplified for the CLISP language by implementing various complicated message passing mechanisms with the MPICH Library in the interpreter.</sentence>
    <sentence>The method only provides an essential parallelization framework; programmers still have to design parallel algorithms for their applications.</sentence>
    <sentence>Even if we parallelize the course timetabling system by this method, we still have to address the same partitioning problems described in this paper.</sentence>
    <sentence>In the second method, a dynamic load balancing programming model is proposed for the parallel CLIPS application (Wu, Lai, &amp; Chang, 2009).</sentence>
    <sentence>The programmers have no need to write any code for load balancing.</sentence>
    <sentence>Instead, with our proposed directives, they only need to indicate (1) which facts can be executed in parallel, (2) which asserted facts should be sent back to the master, (3) what the slave process should do, and (4) what are the reduce operations after the master receives the returned facts.</sentence>
    <sentence>Accordingly, the interpreter will assign the appropriate chunk of facts to each slave depending on the individual computing power, resulting in better load balancing.</sentence>
    <sentence>Therefore, it is very easy for programmers to write parallel CLIPS applications with load balancing capacities.</sentence>
    <sentence>Because the method is only applicable to the applications full of data parallelism, we cannot parallelize the course timetabling system by this method.</sentence>
  </section>
  <section name="The course timetabling expert system">
    <sentence>We proposed integrating expert systems and constraint programming to implement a course timetabling system (Lai et al., 2008).</sentence>
    <sentence>Expert systems are utilized to incorporate knowledge into the timetabling system and to provide a reasoning capability for knowledge deduction.</sentence>
    <sentence>The constraint hierarchy and the constraint network are utilized to capture hard and soft constraints and to reason about constraints by using constraint satisfaction and relaxation techniques.</sentence>
    <sentence>We propose a 4-tier system framework to implement timetabling systems.</sentence>
    <sentence>In the presentation tier, clients can manipulate data (e.g., courses, instructors, classrooms, preference time slots and exclusion time slots) via a browser.</sentence>
    <sentence>The flow control tier receives requests from clients and controls the system flow.</sentence>
    <sentence>In the business logic tier, the application software receives system messages from the web server and accesses the database in the DB server.</sentence>
    <sentence>Scheduling rules and domain knowledge are incorporated into the knowledge base.</sentence>
    <sentence>When scheduling starts, data stored in the DB server are translated into facts that are loaded into the working memory.</sentence>
    <sentence>By matching facts and rules, the inference engine can make inferences that achieve a solution based on the scheduling rules and domain knowledge.</sentence>
    <sentence>The results are stored in the database and are displayed in the web page.</sentence>
    <sentence>The clients then decide to approve, adjust or reschedule according to the analysis of results.</sentence>
    <sentence>Expert systems are utilized to incorporate knowledge into the timetabling system and to provide the reasoning capability for knowledge deduction.</sentence>
    <sentence>CLIPS is a productive development and delivery expert system tool that provides a complete environment for the construction of expert systems.</sentence>
    <sentence>The Web pages and the application software are implemented using JSP and Java.</sentence>
    <sentence>We adopt JClips (Menken, 2009) to combine CLIPS with Java by embedding the CLIPS engine in Java applications.</sentence>
    <sentence>In our previous work (Lai, 2007), we proposed a Knowledge Management through Knowledge Engineering (KMKE) approach to capturing knowledge Conceptual Graphs (CGs) and translating knowledge into CLIPS rules.</sentence>
    <sentence>Both scheduling rules and domain knowledge are represented as CLIPS rules and are stored in the knowledge base.</sentence>
    <sentence>A feasible solution can be inferred from these rules and existing facts.</sentence>
    <sentence>The inference engine makes inferences by deciding which rules are satisfied by facts and then applies the satisfied rules.</sentence>
    <sentence>Separating out the knowledge base, the facts, and the inference engine in expert systems provides greater flexibility in supporting changes.</sentence>
    <sentence>Changes in requirements can be mapped to the modification of corresponding rules in the knowledge base, while changes in data can be mapped to the modification of facts.</sentence>
    <sentence>When facts need to be changed, the clients can modify the database via a web page.</sentence>
    <sentence>New data can then be translated automatically into CLIPS facts in the working memory.</sentence>
    <sentence>On the other hand, knowledge engineers can add or modify the corresponding rules when the requirements are changed.</sentence>
    <sentence>Furthermore, as the inference engine is independent of the actual rules and facts, it can remain unchanged while the rules and facts are changed.</sentence>
    <sentence>Course timetabling can be formulated as a constraint satisfaction problem by (1) treating the time slots of courses as a set of variables, each of which must be instantiated in a particular domain and (2) considering constraints as predicates on variables.</sentence>
    <sentence>A solution means a state in which the values of variables satisfy all predicates simultaneously.</sentence>
    <sentence>Constraints can be classified as hard or soft.</sentence>
    <sentence>A feasible solution to course timetabling should satisfy all hard constraints and as many soft constraints as possible.</sentence>
    <sentence>We utilize a constraint hierarchy to capture hard and soft constraints and a constraint network to reason about constraints.</sentence>
    <sentence>A constraint hierarchy (Kumar, 1992) can be established in terms of the strength (denoted as C0, …, Cn) associated with each constraint.</sentence>
    <sentence>Constraints at the C0 level are the strongest and cannot be violated.</sentence>
    <sentence>The remaining constraints are classified into different levels of strength (i.e., C1, …, Cn) and can be relaxed to attain a feasible solution.</sentence>
    <sentence>This constraint hierarchy is useful for reasoning about constraints using constraint satisfaction and relaxation techniques.</sentence>
    <sentence>A constraint network (Mackworth, 1977) can then be built level by level from the constraints at the top level of the hierarchy downwards.</sentence>
    <sentence>A feasible solution is achieved when all top-level constraints and as many weak constraints as possible can be satisfied simultaneously.</sentence>
    <sentence>We adopt the salience of rules (the priority of rules) in CLIPS to realize the strength of constraints.</sentence>
    <sentence>Rules with higher salience are executed and satisfied first.</sentence>
    <sentence>All scheduling constraints in the constraint hierarchy can be represented as CLIPS rules with salience.</sentence>
    <sentence>The clients manipulate data via web pages, and the data stored in the Oracle DB server are translated into CLIPS facts.</sentence>
    <sentence>The CLIPS inference engine can then make inferences that achieve a feasible solution for the constraint network automatically.</sentence>
    <sentence>To construct the course timetabling expert system, the requirements of instructors and resources are translated into facts; expert knowledge, hard and soft constraints are converted into rules; and the inference can draw a feasible timetable according to the facts and rules, as shown in Fig 1.</sentence>
    <sentence>The construction of the course timetabling expert system Fig 1.</sentence>
    <sentence>The construction of the course timetabling expert system.</sentence>
  </section>
  <section name="Parallel version">
    <sentence>Although the proposed course timetabling expert system is applicable to any department by establishing scheduling rules, time before a feasible timetable is available is considerable because the inference engine is CLIPS-based.</sentence>
    <sentence>Notably, CLIPS is not an algorithmic language; thus, no explicit algorithm is exists in a CLIPS program.</sentence>
    <sentence>To reduce execution time, the course timetabling system is executed in parallel on the emerging cluster system.</sentence>
    <sentence>Section 4.1 introduces the basic parallelization method and Section 4.2 further explains how to divide rules correctly.</sentence>
    <sentence>Finally, Section 4.3 implements the parallel version of the course timetabling system on a cluster system.</sentence>
    <sentence>Parallelization method The greatest challenge is inherent serialization of the inference on course timetabling.</sentence>
    <sentence>Basically, courses must be scheduled on a one-by-one basis.</sentence>
    <sentence>When scheduling a course, one has to determine whether the course satisfies all constraints and whether it conflicts with other courses already scheduled.</sentence>
    <sentence>If the timetabling is parallelized by partitioning the inference according to a certain resource, such as a class or professor, the merging process remains a sequential procedure.</sentence>
    <sentence>One has to determine whether the merged result satisfies all constraints.</sentence>
    <sentence>For example, if the whole process of timetabling is divided according to classes, different class timetables can be scheduled independently and executed in parallel.</sentence>
    <sentence>However, due to multiple class timetables are scheduled in parallel, more than one class timetable may require the same classroom or professor during the same time slot.</sentence>
    <sentence>Therefore, the merging process has to solve conflicts.</sentence>
    <sentence>Similarly, if a whole timetable is divided according to professor, two professors may have the same class for the same time slot, even though they teach different courses.</sentence>
    <sentence>Regardless of which resource is used to divide the timetable, the problem of allocating the same resource to more than one timetable for the same time slot always exists.</sentence>
    <sentence>To solve such conflicts, each timetable has must be compared with another timetable to determine whether conflicts exist.</sentence>
    <sentence>However, since all scheduling results for timetables must be analyzed one by one, the merging process may generate a new performance bottleneck because the merging process must be executed sequentially by the CLIPS inference engine.</sentence>
    <sentence>Therefore, timetabling must be parallelized using different method.</sentence>
    <sentence>Instead of dividing the whole inference process according to a resource, courses are scheduled in a one-by-one manner and the inference process of scheduling one course is parallelized according to the following observation.</sentence>
    <sentence>When a course, represented as a fact, is selected for inference, all rules will be matched with the course using a one-by-one method in the decreasing order of the salience value of rules.</sentence>
    <sentence>If a course is scheduled in some time slots by a certain rule, the remaining rules with relatively lower priorities will not be inferred for this course; thus, another course will be selected for the next scheduling step, which again starts from the rule with the highest salience value.</sentence>
    <sentence>For instance, we assume the inference process for scheduling one course consists of three rules, RA, RB and RC, and their salience values are 30, 20, and 10, respectively.</sentence>
    <sentence>In the original sequential inference process, when a course can be scheduled by rule RA, whether rules RCB and RCC can be used to schedule the course is not tested.</sentence>
    <sentence>However, if rule RA cannot be used for a course, rule RB will be inferred next for the same course.</sentence>
    <sentence>Similarly, if the course can be scheduled using rule RB, rule RC will not be tested.</sentence>
    <sentence>Thus, rule RC will be tested when RA and RB cannot be applied to schedule the course.</sentence>
    <sentence>Basically, the inference behavior for scheduling one course is the same as the nested if–then–else structure in a conventional algorithmic language such as C and Java.</sentence>
    <sentence>To parallelize the nested if–then–else-like inference process for scheduling one course, this work uses a novel parallelization method.</sentence>
    <sentence>The rules for scheduling one course are divided into multiple prioritized rule clusters according to the salience value, where each rule cluster consists of multiple rules.</sentence>
    <sentence>When a course is scheduled, all rule clusters are executed in parallel by slave processes and each reports whether it has obtained a feasible solution.</sentence>
    <sentence>After the master process receives all scheduling results from slave processes, a course is scheduled according to the feasible solution returned from the rule cluster that has the highest priority among pieces with feasible solutions.</sentence>
    <sentence>No complex merging phase is required when using the proposed parallelization method.</sentence>
    <sentence>The following partitioning guideline is utilized to divide all the rules for scheduling one course into rule clusters.</sentence>
    <sentence>Partitioning guideline 1.</sentence>
    <sentence>Rules are sorted and divided according to their individual salience values.</sentence>
    <sentence>If a rule Ri in one rule cluster RCA has a salience value exceeding that of a rule Rj in another rule cluster RCB, any rule in RCA must have a salience value exceeding that of any rule in RCB.</sentence>
    <sentence>Similarly, if a rule Ri in one rule cluster RCA has a salience value smaller than that of a rule Rj in another rule cluster RCB, any rule in RCA must have a salience value smaller than that of any rule in RCB.</sentence>
    <sentence>Any two rules that have the same salience value must belong to the same rule cluster.</sentence>
    <sentence>For example, if six rules exist, R1, R2, R3, R4, R5 and R6, for scheduling one course, their salience values are 60, 50, 40, 30, 20 and 10, respectively.</sentence>
    <sentence>When scheduling one course, R1 will be checked first to determine whether the course can be scheduled according to this rule.</sentence>
    <sentence>If so, another course will then be scheduled.</sentence>
    <sentence>However, if R1 cannot schedule the course, R2 will be tested.</sentence>
    <sentence>The remaining rules are tested in a one-by-one manner using the same above process according to their inference priorities.</sentence>
    <sentence>Generally, a rule Ri will be tested only when any rule Rj cannot be applied to schedule a course, where j &lt; i.</sentence>
    <sentence>To parallelize the inference, if we want to divide the six rules into three rule clusters, RCA, RCB and RCC, there are 10 possible partition results (Fig 2).</sentence>
    <sentence>Ten possible partition results for the six rules Fig 2.</sentence>
    <sentence>Ten possible partition results for the six rules.</sentence>
    <sentence>Without loss generality, we assume RCA includes R1 and R2, RCB includes R3 and R4, and RCC includes R5 and R6.</sentence>
    <sentence>To schedule one course, the three rule clusters will be executed in parallel.</sentence>
    <sentence>Each rule cluster is inferred by a slave process.</sentence>
    <sentence>Initially, the master process broadcasts all slaves for the course that will be scheduled next.</sentence>
    <sentence>Next, each slave performs inference for the course by matching the course with the rules in its rule cluster.</sentence>
    <sentence>Note that each rule cluster is inferred by an independent inference engine.</sentence>
    <sentence>After inference, each slave process sends a message back to the master process, reporting whether it has found a solution for scheduling the current course.</sentence>
    <sentence>Finally, the master process decides which solution will be adopted by selecting the solution inferred by the rule cluster that has the highest priority among all rule clusters with solutions.</sentence>
    <sentence>Before scheduling the next course, the chosen solution must be asserted into each inference engine.</sentence>
    <sentence>This is necessary because each inference engine must know which time slots have been allocated to the current course before it starts scheduling the next course.</sentence>
    <sentence>We assume that only RCB and RCC have solutions (Fig 3).</sentence>
    <sentence>Since RCB has a higher priority than RCC, solution SB will be adopted for the current course.</sentence>
    <sentence>The parallel execution of three rule clusters Fig 3.</sentence>
    <sentence>The parallel execution of three rule clusters.</sentence>
    <sentence>Improper partitioning problems According to the proposed parallelization method described in the previous subsection, rules will be divided into several rule clusters according to the first partitioning guideline in the preceding subsection.</sentence>
    <sentence>However, some restrictions must be applied to rule partitioning; otherwise, improper division may result in incorrect solutions, infinite loops or even runtime errors because of CLIPS properties.</sentence>
    <sentence>Consider the following example.</sentence>
    <sentence>A rule Rx has one action, Am, listed on its right hand side, where Am must be inferred by another rule Ry.</sentence>
    <sentence>If all conditions of rule Rx are satisfied at run time, action Am will be asserted into the knowledge base for further inference.</sentence>
    <sentence>The inference engine then uses Ry to infer Am.</sentence>
    <sentence>However, if Rx is in rule cluster RCA, and Ry is in RCB, after division, action Am cannot be inferred because Ry is not in its rule cluster.</sentence>
    <sentence>To cope with this problem, RCB should include Ry to ensure that Am can be inferred by Ry.</sentence>
    <sentence>However, after inferring Am by Ry, the inference engine may require other rules not in RCB for further inference.</sentence>
    <sentence>Thus, an increasing number of rules must be included in RCB to draw a conclusion by further inference.</sentence>
    <sentence>That is, all rules in the inference chain must be included in the same rule cluster; this is what we call self-containment.</sentence>
    <sentence>If this situation occurs, parts of the inference for scheduling one course will be executed concurrently on multiple rule clusters, resulting in poor or no performance improvement.</sentence>
    <sentence>To cope with this problem, the following partitioning guideline is proposed.</sentence>
    <sentence>Partitioning guideline 2.</sentence>
    <sentence>Each rule cluster must satisfy the self-containment property.</sentence>
    <sentence>Moreover, except rules consisting of only leaf actions, no rules can be replicated in multiple rule clusters, where a leaf action is an action that does not require other rules for further inference.</sentence>
    <sentence>For example, a CLIPS program consists of five rules (Fig 4).</sentence>
    <sentence>Two rules, rule-1 and rule-5, will assert fact-A into the knowledge base, such that rule-6 is needed for rule-1 and rule-5 for further inference.</sentence>
    <sentence>Rule-3 will assert fact-1, such that both rule 1 and rule 2 are required for rule-3 for further inference, and rule-4 will assert fact-3, which requires rule-3.</sentence>
    <sentence>Fig 5 shows the inference relationship between rules; each relationship is indicated by an arrow.</sentence>
    <sentence>Generally, if rule A requires rule B for further inference, an arrow is drawn from A to B.</sentence>
    <sentence>To satisfy the self-containment property, rule-1, rule-2, rule-3 and rule-6 are grouped into a rule cluster.</sentence>
    <sentence>Similarly, rule-4, rule-5 and rule-6 are grouped into another rule cluster.</sentence>
    <sentence>Notably, although rule-6 is replicated in these two rule clusters, the partition still follows the proposed partitioning guideline because rule-6 only has a leaf action, i.e., 〈action 6〉, which does not require other rules for further inference.</sentence>
    <sentence>An example CLIPS program consisting of five rules Fig 4.</sentence>
    <sentence>An example CLIPS program consisting of five rules.</sentence>
    <sentence>The inference relation between rules and how they are partitioned into two rule… Fig 5.</sentence>
    <sentence>The inference relation between rules and how they are partitioned into two rule clusters.</sentence>
    <sentence>Another problem may occur when rules are divided improperly.</sentence>
    <sentence>Consider the following example.</sentence>
    <sentence>Three rules, R1, R2 and R3, have salience values of 100, 80 and 60, respectively.</sentence>
    <sentence>All these rules infer facts of the same type, called Type t. Moreover, rule R3 will modify a fact of Type t, such that all Type t facts will be re-matched with the three rules.</sentence>
    <sentence>Consequently, an inference loop exists among R1, R2 and R3.</sentence>
    <sentence>That no possible ways to infer the current fact is common; thus, a scheduled fact must be removed or modified to find a way to re-schedule the current fact.</sentence>
    <sentence>For example, in the course timetabling application, many possible ways exist for scheduling a course.</sentence>
    <sentence>If all these rules fail to schedule a course, the rule with the lowest priority will remove a scheduled course to open up time slots.</sentence>
    <sentence>After a scheduled course is removed, all rules are applied again to the current course as new time slots are available.</sentence>
    <sentence>Notably, the three rules are not interdependent; thus, these rules are called parallel rules.</sentence>
    <sentence>In the proposed parallelization method, these rules can be divided and then inferred in parallel.</sentence>
    <sentence>If R3 and R1 are inserted into the same rule cluster, these two rules construct a new inference loop.</sentence>
    <sentence>Consequently, the inference engine may draw a false conclusion or fall into an infinite inference loop because rule R2 is not considered.</sentence>
    <sentence>A similar problem occurs when only R3 and R2 are in the same rule cluster.</sentence>
    <sentence>Conversely, no problem occurs when R3 is in an independent rule cluster, regardless of whether R1 and R2 are in the same rule cluster or not.</sentence>
    <sentence>Another possible problem-free method is to group these three rules in the same rule cluster.</sentence>
    <sentence>However, if an inference loop has too many rules, the loop may become a performance bottleneck.</sentence>
    <sentence>In the worst case, all rules in a CLIPS program, such as the course timetabling application, will construct a single inference loop.</sentence>
    <sentence>Therefore, this work proposes another partitioning guideline.</sentence>
    <sentence>Partitioning guideline 3.</sentence>
    <sentence>If an inference loop has too many rules, the rule with the lowest priority in an inference loop should be in an independent rule cluster, and the other rules in the loop can be divided arbitrarily.</sentence>
    <sentence>For example, a CLIPS program consists of three rules (Fig 6).</sentence>
    <sentence>Apparently, these rules do not rely on one another for further inference and can be inferred in parallel utilizing the proposed parallelization method.</sentence>
    <sentence>However, because the rule rule-none-matched will retract a fact of the type data, the knowledge base is modified and the inference engine will then re-match the fact, whose status field is enabled, with rule-1 and rule-2.</sentence>
    <sentence>Thus, these three rules construct an inference loop.</sentence>
    <sentence>According to the third partitioning guideline, two possible partitioning methods exist (Fig 7) because the rule-none-matched rule must be in an independent rule cluster.</sentence>
    <sentence>In the first partitioning method, rule-1 and rule-2 are grouped into a single rule cluster.</sentence>
    <sentence>In the second partitioning method, rule-1 and rule-2 are assigned to two different rule clusters.</sentence>
    <sentence>An example CLIPS program consisting of three rules Fig 6.</sentence>
    <sentence>An example CLIPS program consisting of three rules.</sentence>
    <sentence>Two partitioning methods for the example CLIPS program (Fig Fig 7.</sentence>
    <sentence>Two partitioning methods for the example CLIPS program (Fig 6).</sentence>
    <sentence>Implementation To execute a CLIPS-based expert system in parallel in a cluster system, the application must be parallelized with MPICH library functions.</sentence>
    <sentence>However, CLIPS language does not support this feature, i.e., one cannot utilize MPICH functions directly from a CLIPS program.</sentence>
    <sentence>Therefore, this work modified the CLIPS inference engine to execute the CLIPS file in parallel because the inference engine is written in C language.</sentence>
    <sentence>Moreover, the inference engine is coded using on the SPMD model (Wilkinson &amp; Allen, 2005) for easy maintenance.</sentence>
    <sentence>At runtime, each inference engine will be executed by an MPI process, and each inference engine will read a CLIPS file when building its own knowledge base.</sentence>
    <sentence>To assign courses in a one-by-one manner and schedule one course in parallel, the proposed programming model is used (Fig 8).</sentence>
    <sentence>A CLIPS file contains only rules and all processes read a CLIPS file when making an inference.</sentence>
    <sentence>The facts are listed in a C file that is linked with the inference engine.</sentence>
    <sentence>Therefore, the facts must be converted into the C-format data.</sentence>
    <sentence>At run time, the data are distributed to multiple processes to reduce execution time when making an inference.</sentence>
    <sentence>Additionally, these C-format data must be converted into the CLIPS format, and then inserted into the fact list in the inference engine.</sentence>
    <sentence>Similarly, inference results must be extracted from the inference engine and sent back to the master process in the C format.</sentence>
    <sentence>The programming model of parallel CLIPS program execution Fig 8.</sentence>
    <sentence>The programming model of parallel CLIPS program execution.</sentence>
    <sentence>The rules of the parallel expert system are divided into four rule clusters using the proposed partition guidelines.</sentence>
    <sentence>Each rule cluster is saved as an independent CLIPS file.</sentence>
    <sentence>At run time, four slave MPI processes are created for the inferences of these four rule clusters.</sentence>
    <sentence>Each slave process is associated with a CLIPS file containing one rule cluster.</sentence>
    <sentence>The master sends courses in a one-by-one manner to all slaves.</sentence>
    <sentence>After receiving one course, each slave process schedules the course according to the rules listed in its associated CLIPS file.</sentence>
    <sentence>As soon as scheduling is complete, each slave sends the inference result back to the master process.</sentence>
    <sentence>Moreover, the facts in the knowledge base will be sent back to the master process.</sentence>
    <sentence>The master then determines which scheduling result will be adopted for the current course after receiving all possible solutions.</sentence>
    <sentence>The scheduling result from the slave that has the highest priority for all salves with a feasible solution is chosen for scheduling the course.</sentence>
    <sentence>Before the master sends the next course to slaves for further inference, the master broadcasts the facts to all slaves that are returned from the chosen slave for the current course.</sentence>
    <sentence>After receiving these facts, each slave replaces the knowledge base by these facts, assuring a consistent knowledge base exists before scheduling the next course.</sentence>
    <sentence>The whole timetabling process is complete when no other courses need to be scheduled.</sentence>
  </section>
  <section name="Performance evaluation">
    <sentence>A course timetabling problem in the Department of Computer Science and Information Engineering at the National Changhua University of Education (NCUE) is used as an illustrative example to demonstrate our approach.</sentence>
    <sentence>The department has 15 faculties, 6 classes, and more than 240 students.</sentence>
    <sentence>The model was tested with real data comprising 45–50 subjects, a schedule of 40 time slots, and 8 classrooms.</sentence>
    <sentence>Based on the requirements, several constraints can be identified that the course scheduling system must satisfy.</sentence>
    <sentence>X1.</sentence>
    <sentence>Instructors usually offer more than one course and these courses should not be scheduled at the same time.</sentence>
    <sentence>X2.</sentence>
    <sentence>A course should not be scheduled at the same time as another required course for the same class.</sentence>
    <sentence>X3.</sentence>
    <sentence>Only one course should be assigned to a classroom at any one time.</sentence>
    <sentence>X4.</sentence>
    <sentence>Only the available time slots for a classroom should be scheduled.</sentence>
    <sentence>X5.</sentence>
    <sentence>The number of students registered for a course should not exceed the seating capacity of the classroom.</sentence>
    <sentence>X6.</sentence>
    <sentence>The assignment of classrooms should meet the requirements of courses.</sentence>
    <sentence>X7.</sentence>
    <sentence>The scheduled times of courses should not fall within the exclusion sets.</sentence>
    <sentence>X8.</sentence>
    <sentence>The scheduled times of courses should fall within the preference sets as much as possible.</sentence>
    <sentence>X9.</sentence>
    <sentence>The lectures for a course should not be scheduled in consecutive time slots during the week.</sentence>
    <sentence>X10.</sentence>
    <sentence>The time slots assigned to an instructor should not exceed four per day.</sentence>
    <sentence>X11.</sentence>
    <sentence>A course should not be scheduled at the same time as another optional course for the same class.</sentence>
    <sentence>Constraints can be further classified as hard or soft: the former have to be satisfied, while the latter are desirable but can be relaxed in order to achieve a feasible solution.</sentence>
    <sentence>In our example, constraints X1–X7 are hard constraints and constraints X8–X11 are soft.</sentence>
    <sentence>This work constructed a cluster consisting of four Intel PCs to evaluate the parallel course timetabling expert system.</sentence>
    <sentence>Table 1 shows the configuration of the cluster system.</sentence>
    <sentence>The MPICH2 library is utilized for inter-process communication.</sentence>
    <sentence>Table 1.</sentence>
    <sentence>The cluster system configuration.</sentence>
    <sentence>Intel Pentium III PC × 6 CPU Intel Pentium III, Coppermine 1000 Mhz Memory 256 MB + 128 MB Swap 779,144 KB HD IDE 10 GB OS RedHat 9.0 Fig 9 compares the execution times of the sequential and parallel course timetabling expert systems.</sentence>
    <sentence>The sequential version is executed in one PC in the cluster system, while the parallel version is executed on five PCs in the cluster system; one for the master process and four for slave processes.</sentence>
    <sentence>The parallel version reduces execution time significantly.</sentence>
    <sentence>The performance can be improved by a factor of 12.47, derived by dividing execution time of the sequential version by that of the parallel version.</sentence>
    <sentence>The speedup is superlinear, i.e., the speedup is more than five when only five PCs are used to execute the parallel version.</sentence>
    <sentence>The reason why one can obtain a superlinear speedup is as follows.</sentence>
    <sentence>Total memory space of the cluster system exceeds than that of one PC.</sentence>
    <sentence>Because CLIPS-based applications are memory-intensive programs, the parallel version can take advantage of this larger memory space.</sentence>
    <sentence>Execution time comparison between sequential and parallel versions Fig 9.</sentence>
    <sentence>Execution time comparison between sequential and parallel versions.</sentence>
  </section>
  <section name="Conclusions">
    <sentence>This work utilizes a novel parallel course timetabling expert system.</sentence>
    <sentence>The course timetabling system is designed using the artificial intelligence approach, which integrates expert systems and constraint programming for implementation.</sentence>
    <sentence>Expert systems are utilized to incorporate knowledge into the timetabling system and provide reasoning capability for knowledge deduction.</sentence>
    <sentence>Separating the knowledge base, facts, and inference engine in expert systems achieves increased flexibility in supporting changes.</sentence>
    <sentence>The constraint hierarchy and constraint network are utilized to capture hard and soft constraints and to reason about constraints using the constraint satisfaction and relaxation techniques.</sentence>
    <sentence>The inference for course timetabling is implemented in CLIPS language.</sentence>
    <sentence>To address the problem in that achieving a feasible timetable by CLIPS inference is time-consuming, this work proposes to parallelize the process of assigning one course in a cluster system.</sentence>
    <sentence>To achieve this objective, one must overcome the significant challenge in that the inference on course timetabling has the inherent serialization nature.</sentence>
    <sentence>This work parallelizes the inference process by using the feature in that the process of scheduling one course is similar to the nested if–then–else structure.</sentence>
    <sentence>The courses are schedule in a one-by-one manner.</sentence>
    <sentence>The rules of scheduling one course are divided into multiple rule clusters according to their individual salience values.</sentence>
    <sentence>Each rule cluster is executed by a slave process.</sentence>
    <sentence>The master process decides which returned solution to adopt for the current course after different solutions are returned from all slaves.</sentence>
    <sentence>The adopted solution is the solution returned from the rule cluster that has the largest salience value among all rule clusters that have feasible solutions.</sentence>
    <sentence>To divide rules into rule clusters, this work points out several possible problems that may occur when rules are divided improperly.</sentence>
    <sentence>The three partitioning guidelines are proposed to address these problems.</sentence>
    <sentence>The first partitioning guideline sorts and divides rules according to their salience values.</sentence>
    <sentence>The salience values in one rule cluster are either all larger or all smaller than any salience value in another rule cluster.</sentence>
    <sentence>The second partitioning guideline ensures that every rule cluster satisfies the self-containment property.</sentence>
    <sentence>Furthermore, with the exception for rules consisting of only leaf actions, no rule can be replicated in multiple rule clusters, where a leaf action is an action that does not require other rules for further inference.</sentence>
    <sentence>The third partitioning guideline is that the rule with the lowest priority in an inference loop should be in an independent rule cluster, and the other rules in the loop can be divided arbitrarily.</sentence>
    <sentence>Finally, this work separates facts and rules into two types of files using a novel programming model.</sentence>
    <sentence>Facts are processed and transmitted in the C language, and rules are inferred in CLIPS language.</sentence>
    <sentence>Inter-process communication in a cluster system is achieved by incorporating the MPICH library into the CLIPS inference engine.</sentence>
    <sentence>Experimental results demonstrate that the proposed parallel timetabling system achieves superlinear speedup when running in a cluster system.</sentence>
    <sentence>Implementation experience and the proposed parallelization method are very useful when designing parallel CLIPS-based expert systems that have the execution feature similar to the course timetabling system.</sentence>
    <sentence>That is, the inference process performs in a similar manner as the nested if–then–else structure in conventional algorithmic languages.</sentence>
    <sentence>By parallel inference, CLIPS-based expert systems can provide a timely response for users.</sentence>
  </section>
</article>
